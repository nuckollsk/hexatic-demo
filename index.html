<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KTHNY-style 2D Melting: WCA Particles + Voronoi Coordination (Solid→Hexatic→Liquid)</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    header { padding: 12px 14px; border-bottom: 1px solid rgba(127,127,127,.35); }
    .wrap { display: grid; grid-template-columns: 1fr; gap: 10px; padding: 12px 14px; max-width: 1100px; margin: 0 auto; }
    @media (min-width: 980px) { .wrap { grid-template-columns: 2fr 1fr; align-items: start; } }
    .card { border: 1px solid rgba(127,127,127,.35); border-radius: 12px; padding: 12px; }
    canvas { width: 100%; height: auto; border-radius: 10px; border: 1px solid rgba(127,127,127,.35); background: rgba(127,127,127,.08); touch-action: none; }
    label { display: grid; grid-template-columns: 160px 1fr 70px; gap: 10px; align-items: center; font-size: 14px; margin: 10px 0; }
    input[type="range"] { width: 100%; }
    button { font-size: 14px; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(127,127,127,.35); background: rgba(127,127,127,.12); cursor: pointer; }
    button:active { transform: translateY(1px); }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; }
    .stats { font-variant-numeric: tabular-nums; font-size: 13px; line-height: 1.55; }
    .muted { opacity: .8; font-size: 12px; }
    .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; border: 1px solid rgba(127,127,127,.35); }
    .legend { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; font-size:12px; opacity:.85; }
    .k { font-weight: 650; }
  </style>
</head>
<body>
  <header>
    <div style="max-width:1100px;margin:0 auto;">
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:baseline;">
        <div style="font-weight:650;">KTHNY-style 2D Melting (WCA particles, periodic box): Solid → Hexatic → Liquid</div>
        <div class="muted">Voronoi/Delaunay coordination coloring: 6 black, 5 red, 7 blue</div>
      </div>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <canvas id="view" width="1000" height="760"></canvas>
      <div class="legend">
        <span class="pill"><span class="k">6 neighbors</span> → black</span>
        <span class="pill"><span class="k">5 neighbors</span> → red</span>
        <span class="pill"><span class="k">7 neighbors</span> → blue</span>
        <span class="pill">periodic boundaries, WCA repulsion, Langevin thermostat</span>
      </div>
      <div class="muted" style="margin-top:10px;">
        This is a particle-based simulator (not a field toy): particles move under a short-range repulsive potential (WCA) with a Langevin thermostat at temperature T.
        Coordination numbers are computed from a periodic Delaunay triangulation (via tiling) every few frames.
        For best results, start cold, let it relax, then raise T across the two-step melting window.
      </div>
    </div>

    <div class="card">
      <div style="font-weight:650;margin-bottom:6px;">Controls</div>

      <label>
        <span>Temperature T</span>
        <input id="T" type="range" min="0.01" max="1.20" step="0.01" value="0.10"/>
        <span id="TVal">0.10</span>
      </label>

      <label>
        <span>Density ρ</span>
        <input id="rho" type="range" min="0.70" max="1.10" step="0.01" value="0.92"/>
        <span id="rhoVal">0.92</span>
      </label>

      <label>
        <span>Grid (N×N)</span>
        <input id="N" type="range" min="22" max="64" step="2" value="40"/>
        <span id="NVal">40</span>
      </label>

      <label>
        <span>Friction γ</span>
        <input id="gamma" type="range" min="0.2" max="6.0" step="0.1" value="2.0"/>
        <span id="gammaVal">2.0</span>
      </label>

      <label>
        <span>dt</span>
        <input id="dt" type="range" min="0.001" max="0.010" step="0.001" value="0.004"/>
        <span id="dtVal">0.004</span>
      </label>

      <label>
        <span>Delaunay rate</span>
        <input id="triRate" type="range" min="1" max="30" step="1" value="8"/>
        <span id="triRateVal">8</span>
      </label>

      <label>
        <span>Draw bonds</span>
        <input id="bonds" type="range" min="0" max="1" step="1" value="0"/>
        <span id="bondsVal">off</span>
      </label>

      <div class="row">
        <button id="toggle">Pause</button>
        <button id="reset">Reset (triangular)</button>
        <button id="quench">Quench (cool)</button>
        <button id="sweep">Auto-sweep T</button>
      </div>

      <div style="font-weight:650;margin:12px 0 6px;">Readouts</div>
      <div class="stats" id="stats"></div>

      <div class="muted" style="margin-top:10px;">
        Practical tuning:
        <ul style="margin:6px 0 0 18px; padding:0;">
          <li>Try ρ≈0.92–1.00. Too low → gasy; too high → sluggish.</li>
          <li>Increase T gradually: defects appear as 5–7 pairs (dislocations), then unpaired 5/7 (disclinations) become common.</li>
          <li>If mobile is slow, reduce N (e.g., 32–36) and/or increase triRate (less frequent triangulation).</li>
        </ul>
      </div>
    </div>
  </div>

<script>
(() => {
  // ------------------------------
  //  Delaunator (fast Delaunay triangulation)
  //  Copyright (c) 2017 Mapbox
  //  ISC License. (Embedded for single-file hosting.)
  // ------------------------------
  // Minified lightly for readability; algorithm unchanged.
  class Delaunator {
    static from(points, getX = p => p[0], getY = p => p[1]) {
      const coords = new Float64Array(points.length * 2);
      for (let i = 0; i < points.length; i++) {
        coords[2 * i] = getX(points[i]);
        coords[2 * i + 1] = getY(points[i]);
      }
      return new Delaunator(coords);
    }
    constructor(coords) {
      const n = coords.length >> 1;
      this.coords = coords;
      const ids = this._ids = new Uint32Array(n);
      for (let i = 0; i < n; i++) ids[i] = i;

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (let i = 0; i < n; i++) {
        const x = coords[2 * i], y = coords[2 * i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
      const cx = (minX + maxX) / 2;
      const cy = (minY + maxY) / 2;

      let i0 = 0, i1 = 0, i2 = 0;
      let minDist = Infinity;
      for (let i = 0; i < n; i++) {
        const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
        if (d < minDist) { i0 = i; minDist = d; }
      }
      const i0x = coords[2 * i0], i0y = coords[2 * i0 + 1];

      minDist = Infinity;
      for (let i = 0; i < n; i++) {
        if (i === i0) continue;
        const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
        if (d < minDist && d > 0) { i1 = i; minDist = d; }
      }
      let i1x = coords[2 * i1], i1y = coords[2 * i1 + 1];

      let minRadius = Infinity;
      for (let i = 0; i < n; i++) {
        if (i === i0 || i === i1) continue;
        const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
        if (r < minRadius) { i2 = i; minRadius = r; }
      }

      let i2x = coords[2 * i2], i2y = coords[2 * i2 + 1];

      if (minRadius === Infinity) {
        // all points collinear
        this.triangles = new Uint32Array(0);
        this.halfedges = new Int32Array(0);
        return;
      }

      if (orient(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
        const tmp = i1; i1 = i2; i2 = tmp;
        i1x = coords[2 * i1]; i1y = coords[2 * i1 + 1];
        i2x = coords[2 * i2]; i2y = coords[2 * i2 + 1];
      }

      const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
      this._cx = center.x;
      this._cy = center.y;

      const dists = new Float64Array(n);
      for (let i = 0; i < n; i++) {
        dists[i] = dist(coords[2 * i], coords[2 * i + 1], this._cx, this._cy);
      }

      quicksort(ids, dists, 0, n - 1);

      this._hashSize = Math.ceil(Math.sqrt(n));
      this._hash = new Int32Array(this._hashSize);
      this._hash.fill(-1);

      const maxTriangles = 2 * n - 5;
      this.triangles = new Uint32Array(maxTriangles * 3);
      this.halfedges = new Int32Array(maxTriangles * 3);
      this.halfedges.fill(-1);

      this._trianglesLen = 0;

      this._hullPrev = new Uint32Array(n);
      this._hullNext = new Uint32Array(n);
      this._hullTri = new Uint32Array(n);
      this._hullHash = new Int32Array(this._hashSize);
      this._hullHash.fill(-1);

      let hullStart = i0;
      this._hullStart = hullStart;
      let hullSize = 3;

      this._hullPrev[i0] = i2;
      this._hullNext[i0] = i1;
      this._hullPrev[i1] = i0;
      this._hullNext[i1] = i2;
      this._hullPrev[i2] = i1;
      this._hullNext[i2] = i0;

      this._hullTri[i0] = 0;
      this._hullTri[i1] = 1;
      this._hullTri[i2] = 2;

      this._hullHash[this._hashKey(i0x, i0y)] = i0;
      this._hullHash[this._hashKey(i1x, i1y)] = i1;
      this._hullHash[this._hashKey(i2x, i2y)] = i2;

      this._addTriangle(i0, i1, i2, -1, -1, -1);

      const e = new Uint32Array(n);

      for (let k = 0; k < ids.length; k++) {
        const i = ids[k];
        const x = coords[2 * i];
        const y = coords[2 * i + 1];

        if (i === i0 || i === i1 || i === i2) continue;

        let start = 0;
        const key = this._hashKey(x, y);
        for (let j = 0; j < this._hashSize; j++) {
          start = this._hullHash[(key + j) % this._hashSize];
          if (start !== -1 && start !== this._hullNext[start]) break;
        }

        start = this._hullPrev[start];
        let t = start;
        let q = this._hullNext[t];

        while (orient(x, y, coords[2 * t], coords[2 * t + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
          t = q;
          q = this._hullNext[t];
          if (t === start) { t = -1; break; }
        }
        if (t === -1) continue;

        let e0 = this._addTriangle(t, i, this._hullNext[t], -1, -1, this._hullTri[t]);
        this._hullTri[i] = this._legalize(e0 + 2);
        this._hullTri[t] = e0;

        hullStart = i;
        this._hullPrev[i] = t;
        this._hullNext[i] = this._hullNext[t];
        this._hullPrev[this._hullNext[t]] = i;
        this._hullNext[t] = i;

        // walk forward
        let n0 = this._hullNext[i];
        while (orient(x, y, coords[2 * n0], coords[2 * n0 + 1], coords[2 * this._hullNext[n0]], coords[2 * this._hullNext[n0] + 1]) < 0) {
          const e1 = this._addTriangle(n0, i, this._hullNext[n0], this._hullTri[i], -1, this._hullTri[n0]);
          this._hullTri[i] = this._legalize(e1 + 2);
          this._hullNext[n0] = this._hullNext[this._hullNext[n0]];
          this._hullPrev[this._hullNext[n0]] = n0;
          n0 = this._hullNext[i];
          hullSize--;
        }

        // walk backward
        let p0 = this._hullPrev[i];
        while (orient(x, y, coords[2 * this._hullPrev[p0]], coords[2 * this._hullPrev[p0] + 1], coords[2 * p0], coords[2 * p0 + 1]) < 0) {
          const e1 = this._addTriangle(this._hullPrev[p0], i, p0, -1, this._hullTri[p0], this._hullTri[this._hullPrev[p0]]);
          this._legalize(e1 + 2);
          this._hullTri[this._hullPrev[p0]] = e1;
          this._hullNext[this._hullPrev[p0]] = p0;
          this._hullPrev[p0] = this._hullPrev[this._hullPrev[p0]];
          p0 = this._hullPrev[i];
          hullSize--;
        }

        this._hullStart = hullStart;

        this._hullHash[this._hashKey(x, y)] = i;
        this._hullHash[this._hashKey(coords[2 * t], coords[2 * t + 1])] = t;
        this._hullHash[this._hashKey(coords[2 * this._hullNext[i]], coords[2 * this._hullNext[i] + 1])] = this._hullNext[i];

        hullSize++;
      }

      this.triangles = this.triangles.subarray(0, this._trianglesLen);
      this.halfedges = this.halfedges.subarray(0, this._trianglesLen);
    }

    _hashKey(x, y) {
      const dx = x - this._cx;
      const dy = y - this._cy;
      return Math.floor(pseudoAngle(dx, dy) * this._hashSize) % this._hashSize;
    }

    _addTriangle(i0, i1, i2, a, b, c) {
      const t = this._trianglesLen;
      this.triangles[t] = i0;
      this.triangles[t + 1] = i1;
      this.triangles[t + 2] = i2;
      this._link(t, a);
      this._link(t + 1, b);
      this._link(t + 2, c);
      this._trianglesLen += 3;
      return t;
    }

    _link(a, b) {
      this.halfedges[a] = b;
      if (b !== -1) this.halfedges[b] = a;
    }

    _legalize(a) {
      const triangles = this.triangles;
      const halfedges = this.halfedges;
      const coords = this.coords;

      const b = halfedges[a];
      if (b === -1) return a;

      const a0 = a - a % 3;
      const b0 = b - b % 3;

      const al = a0 + (a + 1) % 3;
      const ar = a0 + (a + 2) % 3;
      const bl = b0 + (b + 2) % 3;
      const br = b0 + (b + 1) % 3;

      const p0 = triangles[ar];
      const pr = triangles[a];
      const pl = triangles[al];
      const p1 = triangles[bl];

      if (inCircle(
        coords[2 * p0], coords[2 * p0 + 1],
        coords[2 * pr], coords[2 * pr + 1],
        coords[2 * pl], coords[2 * pl + 1],
        coords[2 * p1], coords[2 * p1 + 1]
      )) {
        triangles[a] = p1;
        triangles[b] = p0;

        const hbl = halfedges[bl];
        const har = halfedges[ar];

        this._link(a, hbl);
        this._link(b, har);
        this._link(ar, bl);

        const brOpp = b0 + (b + 2) % 3;
        this._legalize(ar);
        this._legalize(brOpp);
      }
      return a;
    }
  }

  function dist(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx*dx + dy*dy; }
  function orient(ax, ay, bx, by, cx, cy) { return (bx-ax)*(cy-ay) - (by-ay)*(cx-ax); }

  function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax, dy = by - ay;
    const ex = cx - ax, ey = cy - ay;
    const bl = dx*dx + dy*dy;
    const cl = ex*ex + ey*ey;
    const d = dx*ey - dy*ex;
    if (d === 0) return Infinity;
    const x = (ey*bl - dy*cl) * 0.5 / d;
    const y = (dx*cl - ex*bl) * 0.5 / d;
    return x*x + y*y;
  }

  function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax, dy = by - ay;
    const ex = cx - ax, ey = cy - ay;
    const bl = dx*dx + dy*dy;
    const cl = ex*ex + ey*ey;
    const d = dx*ey - dy*ex;
    const x = ax + (ey*bl - dy*cl) * 0.5 / d;
    const y = ay + (dx*cl - ex*bl) * 0.5 / d;
    return { x, y };
  }

  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px, dy = ay - py;
    const ex = bx - px, ey = by - py;
    const fx = cx - px, fy = cy - py;

    const ap = dx*dx + dy*dy;
    const bp = ex*ex + ey*ey;
    const cp = fx*fx + fy*fy;

    return dx*(ey*cp - bp*fy) - dy*(ex*cp - bp*fx) + ap*(ex*fy - ey*fx) < 0;
  }

  function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4;
  }

  function quicksort(ids, dists, left, right) {
    if (right - left <= 20) {
      for (let i = left + 1; i <= right; i++) {
        const temp = ids[i];
        const tempDist = dists[temp];
        let j = i - 1;
        while (j >= left && dists[ids[j]] > tempDist) {
          ids[j + 1] = ids[j--];
        }
        ids[j + 1] = temp;
      }
      return;
    }
    const mid = (left + right) >> 1;
    let i = left + 1;
    let j = right;
    swap(ids, mid, i);
    if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

    const temp = ids[i];
    const tempDist = dists[temp];
    while (true) {
      do i++; while (dists[ids[i]] < tempDist);
      do j--; while (dists[ids[j]] > tempDist);
      if (j < i) break;
      swap(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp;

    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
  function swap(arr, i, j) { const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; }

  // ------------------------------
  // Particle simulation (WCA + Langevin)
  // ------------------------------
  const TAU = Math.PI * 2;
  const clamp = (x,a,b) => Math.max(a, Math.min(b, x));

  function mulberry32(seed) {
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }
  function gaussian(rng) {
    let u = 0, v = 0;
    while (u === 0) u = rng();
    while (v === 0) v = rng();
    return Math.sqrt(-2*Math.log(u)) * Math.cos(TAU*v);
  }

  // WCA parameters (reduced units): sigma=1, epsilon=1
  const sigma = 1.0;
  const eps = 1.0;
  const rc = Math.pow(2, 1/6) * sigma;
  const rc2 = rc * rc;

  function wcaForce(r2) {
    // returns scalar prefactor for force: F_vec = f * r_vec
    // LJ: 24 eps (2 (sigma^12)/r^13 - (sigma^6)/r^7)
    // In terms of r2: inv2 = 1/r2; inv6 = inv2^3; inv12 = inv6^2
    const inv2 = 1 / r2;
    const inv6 = inv2 * inv2 * inv2;
    const inv12 = inv6 * inv6;
    // magnitude / r: 24 eps inv2 (2 inv12 - inv6)
    return 24 * eps * inv2 * (2 * inv12 - inv6);
  }

  // ------------------------------
  // Spatial hashing (cell list)
  // ------------------------------
  function makeCells(L, cellSize) {
    const n = Math.max(1, Math.floor(L / cellSize));
    return { n, cellSize: L / n, head: new Int32Array(n*n), next: null };
  }

  function buildCellList(state) {
    const { Np, x, y, L, cells } = state;
    cells.head.fill(-1);
    if (!cells.next || cells.next.length !== Np) cells.next = new Int32Array(Np);
    const n = cells.n;
    const cs = cells.cellSize;

    for (let i=0;i<Np;i++) {
      const cx = Math.floor(x[i] / cs) % n;
      const cy = Math.floor(y[i] / cs) % n;
      const c = cy*n + cx;
      cells.next[i] = cells.head[c];
      cells.head[c] = i;
    }
  }

  function forNeighbors(state, i, fn) {
    const { x, y, L, cells } = state;
    const n = cells.n;
    const cs = cells.cellSize;
    const xi = x[i], yi = y[i];
    let cx = Math.floor(xi / cs) % n;
    let cy = Math.floor(yi / cs) % n;

    for (let oy=-1; oy<=1; oy++) {
      for (let ox=-1; ox<=1; ox++) {
        const nx = (cx + ox + n) % n;
        const ny = (cy + oy + n) % n;
        let j = cells.head[ny*n + nx];
        while (j !== -1) {
          if (j !== i) fn(j);
          j = cells.next[j];
        }
      }
    }
  }

  function minImage(dx, L) {
    if (dx >  0.5*L) dx -= L;
    if (dx < -0.5*L) dx += L;
    return dx;
  }

  // ------------------------------
  // Periodic Delaunay-based coordination (tiling trick)
  // ------------------------------
  function computeCoordinationPeriodic(state) {
    const { Np, x, y, L } = state;

    // Build 3x3 tiled points for periodic triangulation
    const pts = [];
    const meta = []; // map tiled index -> original index
    const shifts = [-1,0,1];
    for (let ty of shifts) {
      for (let tx of shifts) {
        const sx = tx * L;
        const sy = ty * L;
        for (let i=0;i<Np;i++) {
          pts.push([x[i] + sx, y[i] + sy]);
          meta.push(i);
        }
      }
    }

    const del = Delaunator.from(pts);
    const tri = del.triangles;

    // Neighbor sets per original point
    const neigh = Array.from({length: Np}, () => new Set());

    for (let t=0; t<tri.length; t+=3) {
      const a = tri[t], b = tri[t+1], c = tri[t+2];
      const ia = meta[a], ib = meta[b], ic = meta[c];
      if (ia !== ib) { neigh[ia].add(ib); neigh[ib].add(ia); }
      if (ib !== ic) { neigh[ib].add(ic); neigh[ic].add(ib); }
      if (ic !== ia) { neigh[ic].add(ia); neigh[ia].add(ic); }
    }

    const deg = new Int16Array(Np);
    for (let i=0;i<Np;i++) deg[i] = neigh[i].size;

    // Optional bonds for drawing: take edges between original indices within neighbor sets.
    // Build unique list from sets (cap per node to avoid pathological growth in liquid).
    const edges = [];
    const seen = new Set();
    for (let i=0;i<Np;i++) {
      for (const j of neigh[i]) {
        const a = Math.min(i,j), b = Math.max(i,j);
        const key = a + ',' + b;
        if (seen.has(key)) continue;
        seen.add(key);
        edges.push([a,b]);
      }
    }

    return { deg, edges };
  }

  // ------------------------------
  // UI + Canvas
  // ------------------------------
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', { alpha: true });
  function resizeCanvasToDisplaySize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const w = Math.max(360, Math.floor(rect.width * dpr));
    const h = Math.max(280, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
  }

  const el = (id) => document.getElementById(id);
  const TEl = el('T'), rhoEl = el('rho'), NEl = el('N'), gammaEl = el('gamma'), dtEl = el('dt');
  const triRateEl = el('triRate'), bondsEl = el('bonds');
  const statsEl = el('stats');
  const toggleEl = el('toggle'), resetEl = el('reset'), quenchEl = el('quench'), sweepEl = el('sweep');

  function setValText() {
    el('TVal').textContent = (+TEl.value).toFixed(2);
    el('rhoVal').textContent = (+rhoEl.value).toFixed(2);
    el('NVal').textContent = (+NEl.value)|0;
    el('gammaVal').textContent = (+gammaEl.value).toFixed(1);
    el('dtVal').textContent = (+dtEl.value).toFixed(3);
    el('triRateVal').textContent = (+triRateEl.value)|0;
    el('bondsVal').textContent = (+bondsEl.value) ? 'on' : 'off';
  }
  for (const input of [TEl, rhoEl, NEl, gammaEl, dtEl, triRateEl, bondsEl]) {
    input.addEventListener('input', () => {
      setValText();
      if (input === rhoEl || input === NEl) rebuild(true);
    });
  }

  let running = true;
  toggleEl.addEventListener('click', () => {
    running = !running;
    toggleEl.textContent = running ? 'Pause' : 'Run';
  });

  let autoSweep = false;
  sweepEl.addEventListener('click', () => {
    autoSweep = !autoSweep;
    sweepEl.textContent = autoSweep ? 'Stop sweep' : 'Auto-sweep T';
  });

  quenchEl.addEventListener('click', () => {
    // quick cool
    TEl.value = '0.05';
    setValText();
  });

  resetEl.addEventListener('click', () => rebuild(true));

  // ------------------------------
  // Build initial triangular lattice in periodic box
  // ------------------------------
  let state = null;
  let geom = { deg: null, edges: [] };
  let frame = 0;
  let last = performance.now();

  function rebuild(newSeed=false) {
    resizeCanvasToDisplaySize();

    const Nside = (+NEl.value)|0;
    const rho = +rhoEl.value;

    const Np = Nside * Nside;

    // In reduced units, area = Np / rho; box length L = sqrt(area)
    const area = Np / rho;
    const L = Math.sqrt(area);

    // triangular lattice spacing a such that density matches: rho = 2/(sqrt(3) a^2)
    const a = Math.sqrt(2 / (Math.sqrt(3) * rho));

    const seed = newSeed ? (Math.random()*1e9)|0 : (state?.seed ?? ((Math.random()*1e9)|0));
    const rng = mulberry32(seed);

    const x = new Float64Array(Np);
    const y = new Float64Array(Np);
    const vx = new Float64Array(Np);
    const vy = new Float64Array(Np);
    const fx = new Float64Array(Np);
    const fy = new Float64Array(Np);

    // Place Nside x Nside points on triangular lattice, wrapped into [0,L)
    // Use basis vectors: (a,0) and (a/2, a*sqrt(3)/2)
    const b2x = 0.5*a;
    const b2y = Math.sqrt(3)/2*a;

    let k = 0;
    for (let j=0;j<Nside;j++) {
      for (let i=0;i<Nside;i++) {
        let px = i*a + j*b2x;
        let py = j*b2y;
        // fold into box
        px = ((px % L) + L) % L;
        py = ((py % L) + L) % L;

        // small random jitter to break symmetry
        px = (px + (rng()-0.5)*0.03*a + L) % L;
        py = (py + (rng()-0.5)*0.03*a + L) % L;

        x[k] = px; y[k] = py;
        vx[k] = (rng()-0.5)*0.1;
        vy[k] = (rng()-0.5)*0.1;
        k++;
      }
    }

    const cells = makeCells(L, rc);

    state = { seed, rng, Np, Nside, rho, L, a, x, y, vx, vy, fx, fy, cells };
    buildCellList(state);
    geom = computeCoordinationPeriodic(state);
    frame = 0;
  }

  function computeForces(state) {
    const { Np, x, y, fx, fy, L } = state;
    fx.fill(0); fy.fill(0);

    // pairwise within neighbor cells
    for (let i=0;i<Np;i++) {
      forNeighbors(state, i, (j) => {
        // Only compute once
        if (j <= i) return;
        let dx = x[j] - x[i];
        let dy = y[j] - y[i];
        dx = minImage(dx, L);
        dy = minImage(dy, L);
        const r2 = dx*dx + dy*dy;
        if (r2 < rc2 && r2 > 1e-12) {
          const f = wcaForce(r2);
          const fxij = f * dx;
          const fyij = f * dy;
          fx[i] -= fxij; fy[i] -= fyij;
          fx[j] += fxij; fy[j] += fyij;
        }
      });
    }
  }

  function stepLangevin(state, T, gamma, dt) {
    const { Np, x, y, vx, vy, fx, fy, L, rng } = state;

    // Langevin: dv = (F - gamma v) dt + sqrt(2 gamma T dt) * N(0,1)
    // dx = v dt
    const sigmaNoise = Math.sqrt(2 * gamma * T * dt);

    for (let i=0;i<Np;i++) {
      vx[i] += (fx[i] - gamma*vx[i]) * dt + sigmaNoise * gaussian(rng);
      vy[i] += (fy[i] - gamma*vy[i]) * dt + sigmaNoise * gaussian(rng);

      x[i] += vx[i] * dt;
      y[i] += vy[i] * dt;

      // periodic wrap
      if (x[i] >= L) x[i] -= L;
      else if (x[i] < 0) x[i] += L;
      if (y[i] >= L) y[i] -= L;
      else if (y[i] < 0) y[i] += L;
    }
  }

  function summarizeDeg(deg) {
    let n5=0, n6=0, n7=0, no=0;
    for (let i=0;i<deg.length;i++) {
      if (deg[i] === 5) n5++;
      else if (deg[i] === 6) n6++;
      else if (deg[i] === 7) n7++;
      else no++;
    }
    const N = deg.length;
    return { n5, n6, n7, no, f5:n5/N, f6:n6/N, f7:n7/N, fo:no/N };
  }

  function computePsi6(state, geom) {
    // Compute a crude global |psi6| from neighbor bonds (Delaunay neighbors)
    // psi6_i = (1/ni) sum_j exp(i 6 theta_ij)
    // Here we estimate by averaging exp(i6 theta) over edges and then per node.
    const { Np, x, y, L } = state;
    const edges = geom.edges;
    const re = new Float64Array(Np);
    const im = new Float64Array(Np);
    const cnt = new Int16Array(Np);

    for (const [a,b] of edges) {
      let dx = x[b] - x[a];
      let dy = y[b] - y[a];
      dx = minImage(dx, L);
      dy = minImage(dy, L);
      const th = Math.atan2(dy, dx);
      const c = Math.cos(6*th);
      const s = Math.sin(6*th);
      re[a] += c; im[a] += s; cnt[a]++;
      re[b] += c; im[b] += s; cnt[b]++;
    }

    let R=0, I=0, n=0;
    for (let i=0;i<Np;i++) {
      const k = cnt[i];
      if (k > 0) {
        const ri = re[i]/k;
        const ii = im[i]/k;
        const mag = Math.hypot(ri, ii);
        // add phase-weighted average
        const ph = Math.atan2(ii, ri);
        R += mag * Math.cos(ph);
        I += mag * Math.sin(ph);
        n++;
      }
    }
    if (n === 0) return 0;
    return Math.hypot(R/n, I/n);
  }

  function draw(state, geom, opts) {
    resizeCanvasToDisplaySize();
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);

    const { Np, x, y, L, a } = state;

    // Map simulation box to canvas with padding
    const pad = Math.floor(Math.min(W,H) * 0.06);
    const box = Math.min(W, H) - 2*pad;
    const ox = (W - box)/2;
    const oy = (H - box)/2;
    const s = box / L;

    // dot radius in pixels
    const r = clamp(0.18 * a * s, 1.0, 4.5);

    if (opts.drawBonds) {
      ctx.save();
      ctx.globalAlpha = 0.20;
      ctx.lineWidth = Math.max(1, 0.03 * a * s);
      ctx.strokeStyle = "rgba(140,140,140,0.75)";
      ctx.beginPath();
      for (const [i,j] of geom.edges) {
        // draw using wrapped shortest image for aesthetics
        let dx = x[j] - x[i];
        let dy = y[j] - y[i];
        dx = minImage(dx, L);
        dy = minImage(dy, L);
        const xi = x[i];
        const yi = y[i];
        const xj = xi + dx;
        const yj = yi + dy;
        ctx.moveTo(ox + xi*s, oy + yi*s);
        ctx.lineTo(ox + xj*s, oy + yj*s);
      }
      ctx.stroke();
      ctx.restore();
    }

    // Points colored by coordination
    const deg = geom.deg;
    ctx.save();
    for (let i=0;i<Np;i++) {
      const d = deg[i];
      let fill;
      if (d === 6) fill = "rgba(0,0,0,0.95)";
      else if (d === 5) fill = "rgba(220,40,40,0.95)";
      else if (d === 7) fill = "rgba(60,120,255,0.95)";
      else fill = "rgba(180,180,180,0.9)";
      ctx.fillStyle = fill;
      ctx.beginPath();
      ctx.arc(ox + x[i]*s, oy + y[i]*s, r, 0, TAU);
      ctx.fill();
    }
    ctx.restore();

    // Overlay text
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(180,180,180,0.92)";
    ctx.font = `${Math.floor(14 * Math.min(window.devicePixelRatio||1,2))}px system-ui, sans-serif`;
    ctx.fillText(opts.title, 14, 26);
    ctx.restore();

    // Box outline
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(160,160,160,0.8)";
    ctx.lineWidth = 1;
    ctx.strokeRect(ox, oy, box, box);
    ctx.restore();
  }

  // ------------------------------
  // Main loop
  // ------------------------------
  setValText();
  rebuild(true);

  function tick(now) {
    const dtWall = Math.min(0.05, (now - last) / 1000);
    last = now;

    const T = +TEl.value;
    const gamma = +gammaEl.value;
    const dt = +dtEl.value;
    const triRate = (+triRateEl.value)|0;

    if (autoSweep) {
      const next = T + 0.0035;
      const maxT = +TEl.max;
      TEl.value = (next > maxT ? 0.01 : next).toFixed(2);
      el('TVal').textContent = (+TEl.value).toFixed(2);
    }

    if (running) {
      // Multiple integration steps per frame (helps stability vs frame rate variation)
      const steps = clamp(Math.floor(dtWall / dt), 1, 6);
      for (let s=0;s<steps;s++) {
        buildCellList(state);
        computeForces(state);
        stepLangevin(state, +TEl.value, gamma, dt);
      }
    }

    if (frame % triRate === 0) {
      // triangulation is expensive; throttle by triRate
      geom = computeCoordinationPeriodic(state);
    }

    const sum = summarizeDeg(geom.deg);
    const psi6 = computePsi6(state, geom);

    statsEl.innerHTML =
      `<div><b>Order / defects</b></div>` +
      `<div>|ψ₆| (global) ≈ ${psi6.toFixed(3)} <span class="muted">(bond-orientational order proxy)</span></div>` +
      `<div style="margin-top:6px;"><b>Coordination fractions</b></div>` +
      `<div>f(6) = ${(100*sum.f6).toFixed(1)}% <span class="muted">(black)</span></div>` +
      `<div>f(5) = ${(100*sum.f5).toFixed(2)}% <span class="muted">(red)</span></div>` +
      `<div>f(7) = ${(100*sum.f7).toFixed(2)}% <span class="muted">(blue)</span></div>` +
      `<div>f(other) = ${(100*sum.fo).toFixed(2)}% <span class="muted">(gray)</span></div>` +
      `<div class="muted" style="margin-top:8px;">Heuristic: Solid → high |ψ₆| and very few 5/7. Hexatic → |ψ₆| stays high while 5–7 pairs proliferate. Liquid → |ψ₆| drops and isolated 5/7 become common.</div>`;

    draw(state, geom, {
      drawBonds: (+bondsEl.value) === 1,
      title: `T=${(+TEl.value).toFixed(2)}  ρ=${(+rhoEl.value).toFixed(2)}  N=${state.Np}  (periodic WCA+Langevin)`
    });

    frame++;
    requestAnimationFrame(tick);
  }

  requestAnimationFrame(tick);
  window.addEventListener('resize', () => rebuild(false));
})();
</script>
</body>
</html>
